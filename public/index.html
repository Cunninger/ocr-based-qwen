<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="> <!-- 1x1 é€æ˜åƒç´ å ä½ç¬¦ -->
    <title>Qwen VL æ™ºèƒ½è¯†åˆ«ç³»ç»Ÿ</title>

    <!-- æ›¿æ¢ polyfill.io ä¸ºæ›´ç¨³å®šçš„ CDN -->
    <script src="https://cdn.bootcdn.net/ajax/libs/core-js/3.30.0/minified.js"></script>
    <script>
    window.MathJax = {
      tex: {
        inlineMath: [["$", "$"]],
        displayMath: [["$$", "$$"]]
      },
      startup: {
        pageReady: () => {
          return MathJax.startup.defaultPageReady().then(() => {
            // MathJax åŠ è½½å®Œæˆååˆ·æ–°å†å²è®°å½• (å¦‚æœ HistoryManager å’Œ currentToken å·²å®šä¹‰)
            if (typeof HistoryManager !== 'undefined' && typeof currentToken !== 'undefined' && currentToken) {
              if (typeof historyManager === 'undefined') { // Ensure historyManager is instantiated
                 historyManager = new HistoryManager();
              }
              historyManager.displayHistory(currentToken);
            }
          });
        }
      },
      options: {
        enableMenu: false
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
    function waitForMathJax(callback, maxTries = 30) {
      let tries = 0;
      const checkMathJax = () => {
        tries++;
        if (window.MathJax && window.MathJax.typesetPromise) {
          callback();
        } else if (tries < maxTries) {
          setTimeout(checkMathJax, 100);
        } else {
           console.warn("MathJax did not load within the timeout period.");
        }
      };
      checkMathJax();
    }
    </script>

    <style>
        * {
          box-sizing: border-box;
          margin: 0;
          padding: 0;
        }
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
          background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
          min-height: 100vh;
          display: flex;
          justify-content: center;
          align-items: center;
          padding: 20px;
          padding-bottom: 80px; /* Add padding for footer */
        }
        .container {
          background: rgba(255, 255, 255, 0.95);
          padding: 2.5rem;
          /* padding-bottom: 4rem; Removed padding as footer is outside */
          border-radius: 16px;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
          width: 90%;
          max-width: 800px;
          transition: all 0.3s ease;
          margin-bottom: 60px; /* Add margin for footer */
        }
        h1 {
          color: #2c3e50;
          margin-bottom: 0.5rem;
          font-size: 2.2rem;
          text-align: center;
          font-weight: 700;
          text-transform: uppercase;
          letter-spacing: 2px;
          background: linear-gradient(135deg, #1a5fb4 0%, #3498db 100%);
          -webkit-background-clip: text;
          -webkit-text-fill-color: transparent;
          text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
          position: relative;
          padding-bottom: 10px;
          animation: titleFadeIn 1s ease-out;
        }
        @keyframes titleFadeIn {
          from {
            opacity: 0;
            transform: translateY(-20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
        h1::after {
          content: "";
          position: absolute;
          bottom: 0;
          left: 50%;
          transform: translateX(-50%);
          width: 100px;
          height: 3px;
          background: linear-gradient(90deg, transparent, #3498db, transparent);
        }
        .subtitle {
          color: #7f8c8d;
          text-align: center;
          font-size: 1.1rem;
          margin-bottom: 1.5rem;
          font-weight: 300;
          letter-spacing: 1px;
          opacity: 0.8;
          animation: subtitleFadeIn 1s ease-out 0.3s both;
        }
        @keyframes subtitleFadeIn {
          from {
            opacity: 0;
            transform: translateY(10px);
          }
          to {
            opacity: 0.8;
            transform: translateY(0);
          }
        }
        .upload-area {
          border: 2px dashed #8e9eab;
          border-radius: 12px;
          padding: 2rem;
          text-align: center;
          transition: all 0.3s ease;
          margin-bottom: 1.5rem;
          cursor: pointer;
          position: relative;
          overflow: hidden;
        }
        .upload-area:hover {
          border-color: #3498db;
          background: rgba(52, 152, 219, 0.05);
        }
        .upload-area.dragover {
          border-color: #3498db;
          background: rgba(52, 152, 219, 0.1);
          transform: scale(1.02);
        }
        .upload-area i {
          font-size: 2rem;
          color: #8e9eab;
          margin-bottom: 1rem;
        }
        .upload-text {
          color: #7f8c8d;
          font-size: 0.9rem;
        }
        #tokens { /* This ID seems unused for input, maybe remove or rename if #cookieInput is meant */
          width: 100%;
          padding: 0.8rem;
          border: 1px solid #dcdde1;
          border-radius: 8px;
          margin-bottom: 1rem;
          font-size: 0.9rem;
          resize: none;
        }
        .result-container {
          margin-top: 1.5rem;
          opacity: 0;
          transform: translateY(20px);
          transition: all 0.3s ease;
        }
        .result-container.show {
          opacity: 1;
          transform: translateY(0);
        }
        .result {
          background: #f8f9fa;
          padding: 1.2rem;
          border-radius: 8px;
          color: #2c3e50;
          font-size: 1rem;
          line-height: 1.6;
          white-space: pre-wrap;
          word-wrap: break-word; /* Ensure long words break */
        }
        .loading {
          display: none;
          text-align: center;
          margin: 1rem 0;
        }
        .loading::after {
          content: '';
          display: inline-block;
          width: 20px;
          height: 20px;
          border: 2px solid #3498db;
          border-radius: 50%;
          border-top-color: transparent;
          animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
        .preview-image {
          max-width: 100%;
          max-height: 200px;
          margin: 1rem 0;
          border-radius: 8px;
          display: none;
        }
        /* ä¾§è¾¹æ æ ·å¼ */
        .sidebar {
          position: fixed;
          right: -400px; /* Initial hidden state */
          top: 0;
          width: 400px; /* Keep width */
          height: 100vh;
          background: rgba(255, 255, 255, 0.95);
          backdrop-filter: blur(10px);
          box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
          transition: right 0.3s ease;
          padding: 30px;
          z-index: 1000;
          overflow-y: auto;
        }
        .sidebar.open {
          right: 0;
        }
        .sidebar-toggle {
          position: fixed;
          right: 20px;
          top: 20px;
          background: #3498db;
          color: white;
          border: none;
          padding: 10px 15px;
          border-radius: 5px;
          cursor: pointer;
          z-index: 1001;
        }
        .sidebar-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 20px;
          padding-bottom: 15px;
          border-bottom: 2px solid #eee;
        }
        .sidebar-header h2 {
          margin: 0;
          color: #2c3e50;
          font-size: 1.5rem;
        }
        .close-sidebar {
          background: none;
          border: none;
          font-size: 1.5rem;
          cursor: pointer;
          color: #7f8c8d;
        }
        .token-section {
          margin-bottom: 25px;
        }
        .token-section label {
          display: block;
          margin-bottom: 10px;
          color: #34495e;
          font-weight: 500;
        }
        .cookie-input-container {
          margin-bottom: 15px;
        }
        #cookieInput { /* Style for the actual cookie input */
          width: 100%;
          padding: 12px;
          border: 2px solid #e9ecef;
          border-radius: 8px;
          font-size: 0.95rem;
          transition: border-color 0.3s ease;
          /* margin-bottom: 15px; Already handled by container */
          resize: vertical;
          min-height: 100px;
          font-family: monospace;
        }
        #cookieInput:focus {
          outline: none;
          border-color: #3498db;
        }
        .cookie-info {
          background: #f8f9fa;
          padding: 12px;
          border-radius: 8px;
          margin-bottom: 15px;
        }
        .cookie-info p {
          margin: 0 0 8px 0;
          color: #2c3e50;
          font-size: 0.9rem;
          word-break: break-all; /* Wrap long token display */
        }
        .cookie-info p:last-child {
          margin-bottom: 0;
        }
        #currentTokenDisplay {
          color: #3498db;
          font-family: monospace;
        }
        .token-expiry {
          color: #7f8c8d;
          font-size: 0.85rem;
        }
        .token-expiry.expired {
          color: #e74c3c;
          font-weight: bold;
        }
        .save-btn {
          background: #3498db;
          color: white;
          border: none;
          padding: 12px 20px;
          border-radius: 8px;
          cursor: pointer;
          width: 100%;
          font-size: 1rem;
          transition: background 0.3s ease;
        }
        .save-btn:hover {
          background: #2980b9;
        }
        /* Token list display (if used, seems redundant now) */
        .token-list {
          margin-top: 25px;
          max-height: calc(100vh - 450px); /* Adjust as needed */
          overflow-y: auto;
        }
        .token-item {
          background: #f8f9fa;
          padding: 15px;
          margin-bottom: 12px;
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.3s ease;
          border: 2px solid transparent;
          word-break: break-all;
        }
        .token-item:hover {
          background: #e9ecef;
          transform: translateX(-5px);
        }
        .token-item.active {
          border-color: #3498db;
          background: #f1f9ff;
        }
        /* Advanced Mode & Prompt */
         .advanced-mode-toggle {
          display: flex;
          align-items: center;
          margin-bottom: 15px;
          padding: 10px;
          background: #f8f9fa;
          border-radius: 8px;
        }
        .advanced-mode-toggle input[type="checkbox"] {
          margin-right: 10px;
          width: 18px; /* Make checkbox slightly larger */
          height: 18px;
          cursor: pointer;
        }
        .advanced-mode-toggle label {
            cursor: pointer; /* Make label clickable */
            flex-grow: 1; /* Allow label to take space */
        }
        .prompt-container {
          display: none; /* Default hidden */
          margin-bottom: 15px;
        }
        .prompt-container.show {
          display: block;
        }
        #promptInput {
          width: 100%;
          padding: 12px;
          border: 2px solid #e9ecef;
          border-radius: 8px;
          font-size: 0.95rem;
          resize: vertical;
          min-height: 120px;
          font-family: monospace;
          line-height: 1.4;
        }
        #promptInput:focus {
          outline: none;
          border-color: #3498db;
        }
        /* History Sidebar */
        .history-sidebar {
          position: fixed;
          left: -400px; /* Initial hidden state */
          top: 0;
          width: 400px;
          height: 100vh;
          background: rgba(255, 255, 255, 0.98);
          backdrop-filter: blur(10px);
          box-shadow: 5px 0 15px rgba(0, 0, 0, 0.1);
          transition: left 0.3s ease;
          padding: 20px;
          z-index: 1000;
          overflow-y: auto;
        }
        .history-sidebar.open {
          left: 0;
        }
        .history-toggle {
          position: fixed;
          left: 20px;
          top: 20px;
          background: #3498db;
          color: white;
          border: none;
          padding: 10px 15px;
          border-radius: 5px;
          cursor: pointer;
          z-index: 1001;
        }
        /* History Item Styling */
        .history-sidebar h2 { /* Style heading inside history sidebar */
            color: #2c3e50;
            font-size: 1.5rem;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }
        .history-item {
          background: #ffffff;
          border-radius: 12px;
          margin-bottom: 20px;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
          overflow: hidden;
          transition: transform 0.2s ease, box-shadow 0.2s ease;
          display: block; /* Vertical layout */
        }
        .history-item:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        }
        .history-image-container {
          position: relative;
          width: 100%;
          height: 200px;
          overflow: hidden;
          background-color: #f0f0f0; /* Placeholder background */
        }
        .history-image {
          width: 100%;
          height: 100%;
          object-fit: cover;
          transition: transform 0.3s ease;
          cursor: pointer;
        }
         .image-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.4);
          display: flex;
          justify-content: center;
          align-items: center;
          opacity: 0;
          transition: opacity 0.3s ease;
          pointer-events: none;
        }
        .history-image-container:hover .image-overlay {
          opacity: 1;
          pointer-events: auto;
        }
        .history-image-container:hover .history-image {
          transform: scale(1.05);
        }
        .overlay-btn {
          background: rgba(255, 255, 255, 0.9);
          color: #2c3e50;
          border: none;
          padding: 8px 16px;
          border-radius: 20px;
          cursor: pointer;
          font-size: 0.9rem;
          transition: all 0.2s ease;
        }
        .overlay-btn:hover {
          background: #ffffff;
          transform: scale(1.05);
        }
        .history-content {
          padding: 16px;
        }
        .history-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 12px;
          padding-bottom: 12px;
          border-bottom: 1px solid #eee;
        }
        .history-time {
          color: #7f8c8d;
          font-size: 0.9rem;
        }
        .history-actions {
          display: flex;
          gap: 8px;
        }
        .action-btn {
          background: none;
          border: 1px solid #e0e0e0;
          padding: 4px 8px;
          border-radius: 4px;
          cursor: pointer;
          font-size: 0.8rem;
          transition: all 0.2s ease;
        }
        .action-btn.copy-btn { color: #3498db; border-color: #3498db; }
        .action-btn.delete-btn { color: #e74c3c; border-color: #e74c3c; }
        .action-btn:hover {
          background: #f8f9fa;
          transform: translateY(-1px);
        }
        .action-btn.copied {
           background-color: #27ae60;
           color: white;
           border-color: #27ae60;
        }
        .history-text {
          color: #2c3e50;
          font-size: 0.95rem;
          line-height: 1.6;
          max-height: 200px;
          overflow-y: auto;
          padding-right: 8px;
          white-space: pre-wrap;
          word-break: break-word;
        }
        .history-text::-webkit-scrollbar { width: 4px; }
        .history-text::-webkit-scrollbar-track { background: #f1f1f1; }
        .history-text::-webkit-scrollbar-thumb { background: #c0c0c0; border-radius: 2px; }
        .no-history {
          text-align: center;
          color: #7f8c8d;
          padding: 2rem 1rem; /* More padding */
          font-style: italic;
        }
        /* Result Area */
        .result-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 10px;
        }
        .copy-btn { /* Style for main result copy button */
          background: #3498db;
          color: white;
          border: none;
          padding: 5px 10px;
          border-radius: 4px;
          cursor: pointer;
          font-size: 0.9rem;
          transition: background 0.3s ease;
        }
        .copy-btn:hover { background: #2980b9; }
        .copy-btn.copied { background: #27ae60; }
        /* Input Controls */
        .input-controls {
          margin-top: 15px;
          width: 100%;
        }
        #base64Input, #urlInput { /* General styles for textareas */
            width: 100%;
            padding: 10px;
            border: 1px solid #dcdde1;
            border-radius: 8px;
            resize: vertical;
            font-size: 14px;
            margin-top: 10px; /* Spacing when visible */
        }
        #base64Input { height: 100px; }
        #urlInput { height: 40px; }
        .button-group {
          display: flex;
          gap: 10px;
          margin-top: 10px;
          justify-content: center;
        }
        .toggle-btn {
          background: #3498db;
          color: white;
          border: none;
          padding: 8px 15px;
          border-radius: 5px;
          cursor: pointer;
          /* margin-top: 10px; Handled by button-group gap */
          transition: background 0.3s ease;
          font-size: 0.9rem; /* Ensure consistent font size */
        }
        .toggle-btn:hover { background: #2980b9; }
        /* Links & Footer */
        .get-cookie-link {
          position: fixed;
          left: 150px;
          top: 22px;
          background: #2ecc71;
          color: white;
          border: none;
          padding: 8px 15px;
          border-radius: 5px;
          cursor: pointer;
          z-index: 1001;
          text-decoration: none;
          font-size: 14px;
          transition: background 0.3s ease;
        }
        .get-cookie-link:hover { background: #27ae60; }
        .github-link {
          position: fixed;
          right: 150px;
          top: 20px;
          background: #333;
          color: white;
          border: none;
          padding: 10px;
          border-radius: 50%;
          cursor: pointer;
          z-index: 1001;
          width: 40px;
          height: 40px;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: background 0.3s ease;
        }
        .github-link:hover { background: #24292e; }
        .github-icon {
          width: 24px;
          height: 24px;
        }
        .footer {
          position: fixed;
          bottom: 0;
          left: 0;
          width: 100%;
          padding: 15px;
          text-align: center;
          background: rgba(255, 255, 255, 0.9);
          backdrop-filter: blur(5px);
          z-index: 900;
          border-top: 1px solid #eee; /* Add a subtle top border */
        }
        /* Removed footer-content wrapper as footer itself is the container now */
        .powered-by {
          color: #7f8c8d;
          font-size: 0.9rem;
        }
        .powered-by a {
          color: #3498db;
          text-decoration: none;
          transition: color 0.3s ease;
          font-weight: 500;
        }
        .powered-by a:hover { color: #2980b9; }
        /* Image Modal */
        .modal {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.9);
          z-index: 2000;
          cursor: pointer;
          transition: opacity 0.3s ease; /* Add transition */
        }
        .modal-content {
          max-width: 90%;
          max-height: 90vh;
          margin: auto;
          display: block;
          position: relative;
          top: 50%;
          transform: translateY(-50%);
          transition: opacity 0.3s ease; /* Add transition */
          opacity: 1; /* Start visible once modal is displayed */
        }
    </style>
</head>
<body>
    <!-- Top Fixed Buttons -->
    <a href="https://chat.qwenlm.ai/" target="_blank" rel="noopener noreferrer" class="get-cookie-link">
      è·å–Cookie
    </a>
    <a href="https://github.com/Cunninger/ocr-based-qwen" target="_blank" rel="noopener noreferrer" class="github-link" title="View on GitHub">
      <svg class="github-icon" viewBox="0 0 16 16" fill="currentColor">
        <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
      </svg>
    </a>
    <button class="sidebar-toggle" id="sidebarToggle">âš™ï¸ Cookieè®¾ç½®</button>
    <button class="history-toggle" id="historyToggle">ğŸ“‹ è¯†åˆ«å†å²</button>

    <!-- Settings Sidebar -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h2>Cookieç®¡ç†</h2>
        <button class="close-sidebar" id="closeSidebar">Ã—</button>
      </div>
      <div class="token-section">
        <label for="cookieInput">è¾“å…¥Cookie</label>
        <div class="cookie-input-container">
          <textarea id="cookieInput" placeholder="åœ¨æ­¤ç²˜è´´ä» chat.qwenlm.ai è·å–çš„å®Œæ•´ Cookie å­—ç¬¦ä¸²..." rows="8"></textarea>
        </div>
        <div class="cookie-info">
          <p>å½“å‰Token: <span id="currentTokenDisplay">æœªè®¾ç½®</span></p>
          <p>è¿‡æœŸæ—¶é—´: <span id="tokenExpiryDisplay" class="token-expiry">æœªçŸ¥</span></p>
        </div>
        <button class="save-btn" id="saveTokens">ä¿å­˜è®¾ç½®</button>
      </div>
      <!-- Token list might be removed if only one cookie is handled -->
      <!-- <div class="token-list" id="tokenList"></div> -->
       <div class="advanced-mode-toggle">
          <input type="checkbox" id="advancedMode">
          <label for="advancedMode">é«˜çº§æ¨¡å¼ (è‡ªå®šä¹‰Prompt)</label>
       </div>
       <div class="prompt-container" id="promptContainer">
          <label for="promptInput">è‡ªå®šä¹‰Prompt</label>
          <textarea id="promptInput" placeholder="è¾“å…¥è‡ªå®šä¹‰prompt...">è¯·è¯†åˆ«å›¾ç‰‡ä¸­çš„å†…å®¹ï¼Œæ³¨æ„ä»¥ä¸‹è¦æ±‚ï¼š\nå¯¹äºæ•°å­¦å…¬å¼å’Œæ™®é€šæ–‡æœ¬ï¼š\n1. æ‰€æœ‰æ•°å­¦å…¬å¼å’Œæ•°å­¦ç¬¦å·éƒ½å¿…é¡»ä½¿ç”¨æ ‡å‡†çš„LaTeXæ ¼å¼\n2. è¡Œå†…å…¬å¼ä½¿ç”¨å•ä¸ª$ç¬¦å·åŒ…è£¹ï¼Œå¦‚ï¼š$x^2$\n3. ç‹¬ç«‹å…¬å¼å—ä½¿ç”¨ä¸¤ä¸ª$$ç¬¦å·åŒ…è£¹ï¼Œå¦‚ï¼š$$\sum_{i=1}^n i^2$$\n4. æ™®é€šæ–‡æœ¬ä¿æŒåŸæ ·ï¼Œä¸è¦ä½¿ç”¨LaTeXæ ¼å¼\n5. ä¿æŒåŸæ–‡çš„æ®µè½æ ¼å¼å’Œæ¢è¡Œ\n6. æ˜æ˜¾çš„æ¢è¡Œä½¿ç”¨\\nè¡¨ç¤º\n7. ç¡®ä¿æ‰€æœ‰æ•°å­¦ç¬¦å·éƒ½è¢«æ­£ç¡®åŒ…è£¹åœ¨$æˆ–$$ä¸­\n\nå¯¹äºéªŒè¯ç å›¾ç‰‡ï¼š\n1. åªè¾“å‡ºéªŒè¯ç å­—ç¬¦ï¼Œä¸è¦åŠ ä»»ä½•é¢å¤–è§£é‡Š\n2. å¿½ç•¥å¹²æ‰°çº¿å’Œå™ªç‚¹\n3. æ³¨æ„åŒºåˆ†ç›¸ä¼¼å­—ç¬¦ï¼Œå¦‚0å’ŒOã€1å’Œlã€2å’ŒZç­‰\n4. éªŒè¯ç é€šå¸¸ä¸º4-6ä½å­—æ¯æ•°å­—ç»„åˆ\n\nä¸è¦è¾“å‡ºä»»ä½•é¢å¤–çš„è§£é‡Šæˆ–è¯´æ˜</textarea>
       </div>
    </div>

    <!-- Main Content Area -->
    <div class="container">
      <h1>Qwen VL æ™ºèƒ½è¯†åˆ«ç³»ç»Ÿ</h1>
      <div class="subtitle">åŸºäºé€šä¹‰åƒé—®å¤§æ¨¡å‹çš„å¤šæ¨¡æ€æ™ºèƒ½è¯†åˆ«å¼•æ“</div>
      <div class="upload-area" id="uploadArea">
        <i>ğŸ“¸</i>
        <div class="upload-text">
          æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œï¼Œç‚¹å‡»ä¸Šä¼ ï¼Œæˆ–ç²˜è´´å›¾ç‰‡/Base64/URL<br>
          æ”¯æŒå¤šç§è¾“å…¥æ–¹å¼
        </div>
        <div class="input-controls">
          <textarea id="base64Input" placeholder="åœ¨æ­¤è¾“å…¥Base64æ ¼å¼çš„å›¾ç‰‡å†…å®¹..." style="display: none;"></textarea>
          <textarea id="urlInput" placeholder="åœ¨æ­¤è¾“å…¥å›¾ç‰‡URL..." style="display: none;"></textarea>
          <div class="button-group">
            <button id="toggleBase64" class="toggle-btn">Base64è¾“å…¥</button>
            <button id="toggleUrl" class="toggle-btn">URLè¾“å…¥</button>
          </div>
        </div>
        <img id="previewImage" class="preview-image" alt="å›¾ç‰‡é¢„è§ˆ">
      </div>
      <div class="loading" id="loading"></div>
      <div class="result-container" id="resultContainer">
        <div class="result-header">
          <span>è¯†åˆ«ç»“æœ</span>
          <button class="copy-btn" id="copyBtn">å¤åˆ¶ç»“æœ</button>
        </div>
        <div class="result" id="result"></div>
      </div>
       <!-- Moved footer outside the container but kept its structure -->
    </div>

    <!-- History Sidebar -->
    <div class="history-sidebar" id="historySidebar">
      <h2>è¯†åˆ«å†å²</h2>
      <div id="historyList">
          <div class="no-history">åŠ è½½å†å²è®°å½•ä¸­...</div>
      </div>
    </div>

    <!-- Image Modal -->
    <div id="imageModal" class="modal">
      <img class="modal-content" id="modalImage" alt="å…¨å±å›¾ç‰‡">
    </div>

    <!-- Footer -->
    <div class="footer">
        <div class="powered-by">
          ç”± <a href="https://chat.qwenlm.ai/" target="_blank" rel="noopener noreferrer">Qwen VL</a> æä¾›æ”¯æŒï¼Œä¸€åˆ‡ä»…ç”¨äºå­¦ä¹ ä½¿ç”¨ï¼
        </div>
    </div>

    <!-- Client-side Javascript -->
    <script>
        // --- History Manager Class ---
        class HistoryManager {
            constructor(maxHistory = 10) {
                this.maxHistory = maxHistory;
            }

            getHistoryKey(token) {
                const prefix = 'imageRecognition_history_';
                // Use a safer identifier if token can be long/complex or empty
                const tokenIdentifier = token && token.length > 8 ? token.substring(0, 8) : (token || 'default');
                return prefix + tokenIdentifier;
            }

            loadHistory(token) {
                if (!token) return []; // Don't load history for empty token
                const key = this.getHistoryKey(token);
                try {
                    const history = localStorage.getItem(key);
                    return history ? JSON.parse(history) : [];
                } catch (e) {
                    console.error("Failed to parse history from localStorage for key:", key, e);
                    localStorage.removeItem(key); // Remove corrupted data
                    return [];
                }
            }

            saveHistory(token, history) {
                 if (!token) return; // Don't save history for empty token
                const key = this.getHistoryKey(token);
                try {
                    // Ensure history doesn't exceed max size before saving
                    const limitedHistory = history.slice(0, this.maxHistory);
                    localStorage.setItem(key, JSON.stringify(limitedHistory));
                } catch (e) {
                    console.error("Failed to save history to localStorage for key:", key, e);
                    if (e.name === 'QuotaExceededError') {
                        alert('æ— æ³•ä¿å­˜æ›´å¤šå†å²è®°å½•ï¼Œæœ¬åœ°å­˜å‚¨ç©ºé—´å·²æ»¡ã€‚è¯·å°è¯•æ¸…ç†å…¶ä»–ç½‘ç«™æ•°æ®ã€‚');
                    }
                }
            }

            addHistory(token, imageData, result) {
                if (!token) {
                    console.warn("Attempted to add history without a valid token.");
                    return;
                }
                let history = this.loadHistory(token);
                const newRecord = {
                    image: imageData, // Store as data URL
                    result: result,
                    timestamp: new Date().toISOString()
                };
                history.unshift(newRecord);
                // Slicing is handled in saveHistory now
                this.saveHistory(token, history);
                this.displayHistory(token); // Update display immediately
            }

            displayHistory(token) {
                const historyListEl = document.getElementById('historyList');
                if (!historyListEl) return;

                 // If no token, show message and clear list
                if (!token) {
                    historyListEl.innerHTML = '<div class="no-history">è¯·å…ˆè®¾ç½® Cookie ä»¥æŸ¥çœ‹å†å²è®°å½•</div>';
                    return;
                }


                const history = this.loadHistory(token);

                if (!Array.isArray(history) || history.length === 0) {
                    historyListEl.innerHTML = '<div class="no-history">å½“å‰ Cookie æ— è¯†åˆ«å†å²</div>';
                    return;
                }

                let html = '';
                history.forEach((record, i) => {
                    const imageUrl = typeof record.image === 'string' && record.image.startsWith('data:') ?
                        record.image :
                        'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; // Placeholder

                    const timestamp = new Date(record.timestamp);
                    const timeStr = isNaN(timestamp) ? 'æ— æ•ˆæ—¥æœŸ' : timestamp.toLocaleString('zh-CN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit'
                    });

                    const escapedResult = record.result ? record.result.replace(/"/g, '"') : 'æ— è¯†åˆ«ç»“æœ';
                    const resultTextDisplay = record.result || 'æ— è¯†åˆ«ç»“æœ';

                    html += `
                      <div class="history-item" data-index="${i}">
                        <div class="history-image-container">
                          <img src="${imageUrl}"
                               class="history-image"
                               alt="å†å²å›¾ç‰‡ #${i + 1}"
                               onerror="this.src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';"
                               onclick="event.stopPropagation(); showFullImage(this.src)">
                          <div class="image-overlay">
                            <button class="overlay-btn" onclick="event.stopPropagation(); showFullImage(this.closest('.history-image-container').querySelector('.history-image').src)">æŸ¥çœ‹å¤§å›¾</button>
                          </div>
                        </div>
                        <div class="history-content">
                          <div class="history-header">
                            <span class="history-time">${timeStr}</span>
                            <div class="history-actions">
                              <button class="action-btn copy-btn" onclick="event.stopPropagation(); copyHistoryResult(${i}, this)">å¤åˆ¶ç»“æœ</button>
                              <button class="action-btn delete-btn" onclick="event.stopPropagation(); deleteHistoryItem(${i})">åˆ é™¤</button>
                            </div>
                          </div>
                          <div class="history-text" data-original-text="${escapedResult}">${resultTextDisplay}</div>
                        </div>
                      </div>
                    `;
                });

                historyListEl.innerHTML = html;

                // Render MathJax for the updated history list
                waitForMathJax(() => {
                    try {
                        if (window.MathJax && historyListEl.childElementCount > 0) {
                           window.MathJax.typesetPromise([historyListEl])
                              .catch(err => console.error("MathJaxæ¸²æŸ“å†å²è®°å½•é”™è¯¯:", err));
                        }
                    } catch (err) {
                        console.error("MathJaxå¤„ç†å†å²è®°å½•é”™è¯¯:", err);
                    }
                });
            }
        } // End of HistoryManager class

        // --- Global State & Elements ---
        let currentToken = '';
        const historyManager = new HistoryManager(); // Instantiate the manager

        // DOM Elements (ensure they exist)
        const uploadArea = document.getElementById('uploadArea');
        const resultDiv = document.getElementById('result');
        const resultContainer = document.getElementById('resultContainer');
        const loading = document.getElementById('loading');
        const previewImage = document.getElementById('previewImage');
        const historyList = document.getElementById('historyList'); // For the display area inside history sidebar
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const cookieInput = document.getElementById('cookieInput');
        const saveTokensBtn = document.getElementById('saveTokens');
        // const tokenList = document.getElementById('tokenList'); // Likely unused element now
        const historySidebar = document.getElementById('historySidebar');
        const historyToggle = document.getElementById('historyToggle');
        const closeSidebarBtn = document.getElementById('closeSidebar');
        const currentTokenDisplay = document.getElementById('currentTokenDisplay');
        const tokenExpiryDisplay = document.getElementById('tokenExpiryDisplay');
        const copyBtn = document.getElementById('copyBtn'); // Main result copy button
        const base64Input = document.getElementById('base64Input');
        const toggleBase64 = document.getElementById('toggleBase64');
        const urlInput = document.getElementById('urlInput');
        const toggleUrl = document.getElementById('toggleUrl');
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImage');
        const advancedMode = document.getElementById('advancedMode');
        const promptContainer = document.getElementById('promptContainer');
        const promptInput = document.getElementById('promptInput');


        // --- Utility Functions ---

        // Debounce
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func.apply(this, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // æ–°å¢: é€šç”¨å¤åˆ¶æ–‡æœ¬å‡½æ•°
        async function copyTextToClipboard(text) {
            if (!text) return false;
            
            // é¦–é€‰ navigator.clipboard API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                try {
                    await navigator.clipboard.writeText(text);
                    return true;
                } catch (clipboardError) {
                    console.warn('Clipboard API failed:', clipboardError);
                    // ç»§ç»­å°è¯•åå¤‡æ–¹æ¡ˆ
                }
            }
            
            // åå¤‡æ–¹æ¡ˆ: ä½¿ç”¨ textarea
            try {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                const successful = document.execCommand('copy');
                textArea.remove();
                return successful;
            } catch (fallbackError) {
                console.error('Fallback copy failed:', fallbackError);
                return false;
            }
        }

        // Show Full Image Modal
        function showFullImage(src) {
            if (!src || src.startsWith('data:image/gif') || !modal || !modalImg) return;
            
            try {
                // å¦‚æœæ˜¯ base64 å›¾ç‰‡å¹¶ä¸”å¤ªé•¿ï¼Œä½¿ç”¨æ–°çª—å£æ‰“å¼€
                if (src.startsWith('data:') && src.length > 32768) {
                    const win = window.open('', '_blank');
                    if (!win) {
                        alert('è¯·å…è®¸æ‰“å¼€å¼¹å‡ºçª—å£ä»¥æŸ¥çœ‹å¤§å›¾');
                        return;
                    }
                    win.document.write(`
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>æŸ¥çœ‹å¤§å›¾</title>
                            <style>
                                body { margin: 0; background: #000; height: 100vh; display: flex; justify-content: center; align-items: center; }
                                img { max-width: 100%; max-height: 100vh; object-fit: contain; }
                            </style>
                        </head>
                        <body>
                            <img src="${src}" alt="Full size image">
                        </body>
                        </html>
                    `);
                    win.document.close();
                    return;
                }

                // å¯¹äºè¾ƒå°çš„å›¾ç‰‡æˆ– URL å›¾ç‰‡ï¼Œä½¿ç”¨modalæ˜¾ç¤º
                modalImg.src = src;
                modal.style.display = 'block';
                modalImg.style.opacity = '0';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        modalImg.style.opacity = '1';
                    });
                });
            } catch (error) {
                console.error('æ˜¾ç¤ºå¤§å›¾å¤±è´¥:', error);
                alert('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•');
                modal.style.display = 'none';
            }

            modalImg.onerror = () => {
                alert('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•');
                modal.style.display = 'none';
            };
        }

        // Read File as Data URL (Async)
        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                if (!file || !file.type.startsWith('image/')) {
                    return reject(new Error("æ— æ•ˆçš„æ–‡ä»¶ç±»å‹"));
                }
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(reader.error);
                reader.readAsDataURL(file);
            });
        }

         // JWT Parsing (basic, no verification)
        function parseJwt(token) {
            try {
                const base64Url = token.split('.')[1];
                if (!base64Url) return null;
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                return JSON.parse(jsonPayload);
            } catch (e) {
                // console.error('JWT è§£æé”™è¯¯:', e); // Be less verbose in console
                return null;
            }
        }

        // Update Token Expiry Display
        function updateTokenExpiryDisplay(token) {
            if (!tokenExpiryDisplay) return;

            if (!token) {
                tokenExpiryDisplay.textContent = 'æœªçŸ¥';
                tokenExpiryDisplay.className = 'token-expiry';
                return;
            }

            const decoded = parseJwt(token);
            if (!decoded || typeof decoded.exp !== 'number') {
                tokenExpiryDisplay.textContent = 'æ— æ³•è§£æ';
                tokenExpiryDisplay.className = 'token-expiry';
                return;
            }

            try {
                 const expiryDate = new Date(decoded.exp * 1000);
                 const now = new Date();
                 const isExpired = expiryDate < now;
                 const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
                 let dateString;
                 try {
                    dateString = expiryDate.toLocaleString('zh-CN', options);
                 } catch(localeError){ // Fallback for environments without full locale support
                    dateString = expiryDate.toISOString().replace('T', ' ').substring(0, 19);
                 }

                 tokenExpiryDisplay.textContent = dateString;

                 if (isExpired) {
                     tokenExpiryDisplay.className = 'token-expiry expired';
                     tokenExpiryDisplay.textContent += ' (å·²è¿‡æœŸ)';
                 } else {
                     tokenExpiryDisplay.className = 'token-expiry';
                 }
            } catch (e) {
                 console.error("Error formatting expiry date:", e);
                 tokenExpiryDisplay.textContent = 'æ ¼å¼åŒ–é”™è¯¯';
                 tokenExpiryDisplay.className = 'token-expiry';
            }
        }

         // Update token display (shortened) and expiry
        function updateTokenDisplay(token) {
            currentToken = token || ''; // Update global state
            if (currentTokenDisplay) {
               currentTokenDisplay.textContent = currentToken ? `${currentToken.slice(0, 10)}...${currentToken.slice(-10)}` : 'æœªè®¾ç½®';
            }
            updateTokenExpiryDisplay(currentToken);
        }


        // --- Core Logic Functions ---

        // Display Result and Render MathJax
        function displayResult(resultText) {
            if (resultDiv && resultContainer && copyBtn) {
                resultDiv.setAttribute('data-original-text', resultText);
                resultDiv.innerHTML = resultText; // Set raw HTML first
                resultContainer.classList.add('show');
                copyBtn.textContent = 'å¤åˆ¶ç»“æœ';
                copyBtn.classList.remove('copied');

                // Render MathJax
                waitForMathJax(() => {
                    try {
                        if (window.MathJax) { // Check if MathJax is available
                           window.MathJax.typesetPromise([resultDiv])
                              .catch(err => console.error("MathJax æ¸²æŸ“ç»“æœé”™è¯¯:", err));
                        }
                    } catch (err) {
                        console.error("MathJax å¤„ç†ç»“æœé”™è¯¯:", err);
                    }
                });
            } else {
                 console.error("Result display elements not found!");
            }
        }

        // Show Error Message
        function showError(message) {
             if (resultDiv && resultContainer && copyBtn) {
                resultDiv.textContent = `å¤„ç†å¤±è´¥: ${message}`;
                resultContainer.classList.add('show');
                copyBtn.textContent = 'å¤åˆ¶ç»“æœ';
                copyBtn.classList.remove('copied');
             }
             if (loading) loading.style.display = 'none'; // Ensure loading is hidden on error
        }

         // Generic API Call Function
        async function makeApiCall(endpoint, options) {
            loading.style.display = 'block';
            resultContainer.classList.remove('show');
            if(resultDiv) resultDiv.innerHTML = ''; // Clear previous results

            try {
                const response = await fetch(endpoint, options);

                if (!response.ok) {
                    let errorMsg = `è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.status}`;
                    try {
                        const errorData = await response.json();
                        errorMsg = errorData.error || JSON.stringify(errorData) || errorMsg;
                    } catch (parseError) {
                        // If parsing JSON fails, use the status text
                        errorMsg = response.statusText || errorMsg;
                    }
                    throw new Error(errorMsg);
                }

                 const data = await response.json();
                 if (endpoint === '/proxy/upload') { // Proxy just returns the upload data
                    return data;
                 } else { // Recognition endpoints should return { success: boolean, ... }
                    if (!data.success) {
                        throw new Error(data.error || 'API è¿”å›è¯†åˆ«å¤±è´¥');
                    }
                    return data; // { success: true, result: ..., type: ... }
                 }

            } catch (error) {
                console.error(`API call to ${endpoint} failed:`, error);
                showError(error.message);
                throw error; // Re-throw to be caught by caller if needed
            } finally {
                 if (loading) loading.style.display = 'none';
            }
        }


        // Process Image File Upload
        async function processImage(file) {
            if (!currentToken) {
                alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­è¾“å…¥æœ‰æ•ˆçš„Cookieå¹¶ä¿å­˜');
                if(sidebar) sidebar.classList.add('open');
                return;
            }
            const savedCookie = localStorage.getItem('imageRecognitionCookie');
            if (!savedCookie) {
                alert('æ— æ³•æ‰¾åˆ°å·²ä¿å­˜çš„Cookieï¼Œè¯·é‡æ–°è®¾ç½®');
                 if(sidebar) sidebar.classList.add('open');
                return;
            }

            let imageDataUrl = '';
            try {
                imageDataUrl = await readFileAsDataURL(file);
                if (previewImage) {
                    previewImage.src = imageDataUrl;
                    previewImage.style.display = 'block';
                }
            } catch (error) {
                console.error("Error reading file for preview:", error);
                 if (previewImage) previewImage.style.display = 'none';
                 // Proceed without preview if reading fails, but log it
            }

            try {
                // 1. Upload file
                const formData = new FormData();
                formData.append('file', file);
                const uploadData = await makeApiCall('/proxy/upload', {
                    method: 'POST',
                    headers: { 'x-custom-cookie': savedCookie },
                    body: formData,
                });

                if (!uploadData || !uploadData.id) throw new Error('æ–‡ä»¶ä¸Šä¼ åæœªè·å–åˆ° imageId');

                // 2. Recognize image
                const recognizeData = await makeApiCall('/recognize', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-custom-cookie': savedCookie,
                        'x-advanced-mode': String(advancedMode.checked),
                        'x-custom-prompt': advancedMode.checked ? btoa(unescape(encodeURIComponent(promptInput.value))) : '',
                    },
                    body: JSON.stringify({ imageId: uploadData.id }),
                });

                displayResult(recognizeData.result);
                if (imageDataUrl) { // Only add history if preview was successful
                    historyManager.addHistory(currentToken, imageDataUrl, recognizeData.result);
                }

            } catch (error) {
                 console.error("Error in processImage:", error);
                 // showError is called within makeApiCall
            }
        }

        // Process Base64 Input
        const processBase64Debounced = debounce(async (base64Content) => {
            if (!base64Content) return;
            if (!currentToken) {
                alert('è¯·å…ˆè®¾ç½®Cookie');
                 if(sidebar) sidebar.classList.add('open');
                return;
            }
            const savedCookie = localStorage.getItem('imageRecognitionCookie');
             if (!savedCookie) {
                alert('æ— æ³•æ‰¾åˆ°å·²ä¿å­˜çš„Cookie');
                 if(sidebar) sidebar.classList.add('open');
                return;
            }

            let imageData = '';
            if (base64Content.startsWith('data:image')) {
                imageData = base64Content;
            } else if (/^[A-Za-z0-9+/=\s]+$/.test(base64Content) && base64Content.length % 4 === 0) {
                 imageData = 'data:image/png;base64,' + base64Content.replace(/\s/g, ''); // Assume PNG
            } else {
                 showError('æ— æ•ˆçš„ Base64 å­—ç¬¦ä¸²');
                 return;
            }

            // Attempt preview
             if (previewImage) {
                 previewImage.src = imageData;
                 previewImage.style.display = 'block';
                 previewImage.onerror = () => { previewImage.style.display = 'none'; }; // Hide if invalid image data
             }


            try {
                 const recognizeData = await makeApiCall('/api/recognize/base64', {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                         'x-custom-cookie': savedCookie,
                         'x-advanced-mode': String(advancedMode.checked),
                         'x-custom-prompt': advancedMode.checked ? btoa(unescape(encodeURIComponent(promptInput.value))) : '',
                     },
                     // Send the original input, let backend handle prefix if needed
                     body: JSON.stringify({ base64Image: base64Content })
                 });

                 displayResult(recognizeData.result);
                 historyManager.addHistory(currentToken, imageData, recognizeData.result); // Use the derived data URL

            } catch (error) {
                 console.error("Error in processBase64:", error);
                 // showError is called within makeApiCall
            }
        }, 1000); // 1 second debounce

        // Process URL Input
        const processUrlDebounced = debounce(async (imageUrl) => {
            if (!imageUrl || (!imageUrl.startsWith('http://') && !imageUrl.startsWith('https://'))) {
                return; // Ignore invalid URLs silently or provide feedback
            }
             if (!currentToken) {
                alert('è¯·å…ˆè®¾ç½®Cookie');
                 if(sidebar) sidebar.classList.add('open');
                return;
            }
             const savedCookie = localStorage.getItem('imageRecognitionCookie');
             if (!savedCookie) {
                alert('æ— æ³•æ‰¾åˆ°å·²ä¿å­˜çš„Cookie');
                 if(sidebar) sidebar.classList.add('open');
                return;
            }

            // Attempt to fetch image for preview (optional but good UX)
            let imageDataForHistory = imageUrl; // Default to URL if fetch fails
             if (previewImage) previewImage.style.display = 'none'; // Hide previous preview
            try {
                const imgResponse = await fetch(imageUrl); // Browser fetches directly
                if (imgResponse.ok) {
                    const blob = await imgResponse.blob();
                    imageDataForHistory = await readFileAsDataURL(blob); // Use dataURL for history/preview
                    if (previewImage) {
                        previewImage.src = imageDataForHistory;
                        previewImage.style.display = 'block';
                        previewImage.onerror = () => { previewImage.style.display = 'none'; };
                    }
                } else {
                    console.warn(`Preview fetch failed for ${imageUrl}: ${imgResponse.statusText}`);
                }
            } catch (previewError) {
                console.warn(`Could not load preview for ${imageUrl}: ${previewError.message}`);
                 if (previewImage) previewImage.style.display = 'none';
            }


            try {
                const recognizeData = await makeApiCall('/api/recognize/url', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-custom-cookie': savedCookie,
                         'x-advanced-mode': String(advancedMode.checked),
                         'x-custom-prompt': advancedMode.checked ? btoa(unescape(encodeURIComponent(promptInput.value))) : '',
                    },
                    body: JSON.stringify({ imageUrl: imageUrl })
                });

                displayResult(recognizeData.result);
                historyManager.addHistory(currentToken, imageDataForHistory, recognizeData.result);

            } catch (error) {
                 console.error("Error in processUrl:", error);
                 // showError is called within makeApiCall
            }
        }, 1000); // 1 second debounce


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // Save Settings Button
            if (saveTokensBtn) {
                saveTokensBtn.addEventListener('click', () => {
                    if (cookieInput) {
                        const cookieValue = cookieInput.value.trim();
                        if (!cookieValue) {
                            alert('è¯·è¾“å…¥Cookie');
                            return;
                        }
                        const tokenMatch = cookieValue.match(/token=([^;]+)/);
                        if (!tokenMatch || !tokenMatch[1]) {
                            alert('Cookieæ ¼å¼æ— æ•ˆï¼Œè¯·ç¡®ä¿åŒ…å« token=... éƒ¨åˆ†');
                             updateTokenDisplay(null); // Clear display
                             localStorage.removeItem('imageRecognitionCookie');
                            return;
                        }
                        localStorage.setItem('imageRecognitionCookie', cookieValue);
                        updateTokenDisplay(tokenMatch[1]);
                        alert('è®¾ç½®å·²ä¿å­˜');
                        historyManager.displayHistory(currentToken); // Refresh history view for the new token
                    }
                });
            }

            // Sidebar Toggles
            if (sidebarToggle && sidebar) sidebarToggle.addEventListener('click', () => sidebar.classList.toggle('open'));
            if (closeSidebarBtn && sidebar) closeSidebarBtn.addEventListener('click', () => sidebar.classList.remove('open'));
            if (historyToggle && historySidebar) historyToggle.addEventListener('click', () => historySidebar.classList.toggle('open'));

            // Drag and Drop Area
            if (uploadArea) {
                uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
                uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                        const file = e.dataTransfer.files[0];
                        if (file && file.type.startsWith('image/')) {
                            processImage(file);
                        } else { alert("è¯·æ‹–æ”¾å›¾ç‰‡æ–‡ä»¶ã€‚"); }
                    }
                });
                // Click to Upload
                uploadArea.addEventListener('click', (e) => {
                    // Only trigger if clicking the area itself, not internal controls
                    if (e.target === uploadArea || e.target.closest('.upload-text') || e.target.tagName === 'I') {
                        const fileInput = document.createElement('input');
                        fileInput.type = 'file';
                        fileInput.accept = 'image/*';
                        fileInput.onchange = (ev) => {
                            if (ev.target.files && ev.target.files[0]) processImage(ev.target.files[0]);
                        };
                        fileInput.click();
                    }
                });
            }

            // Paste Handling (Global)
             document.addEventListener('paste', (e) => {
                const targetTagName = e.target.tagName.toLowerCase();
                // Ignore paste events inside text inputs/textareas
                if (targetTagName === 'input' || targetTagName === 'textarea') {
                     // If pasting into specific inputs, let their handlers work (or default paste)
                     if (['base64Input', 'urlInput', 'cookieInput', 'promptInput'].includes(e.target.id)) {
                         // Let the 'input' event handler for base64/url handle it via debounce
                         return;
                     }
                }

                 // Check for image files in clipboard
                if (e.clipboardData?.files?.length > 0) {
                    const file = e.clipboardData.files[0];
                    if (file?.type.startsWith('image/')) {
                        e.preventDefault(); // Prevent pasting file name/path as text
                        processImage(file);
                        return; // Handled image paste
                    }
                }

                // Optional: Check for text that looks like Base64 or URL when pasting outside inputs
                // const text = e.clipboardData?.getData('text/plain');
                // if (text && (targetTagName !== 'input' && targetTagName !== 'textarea')) {
                //    // Add heuristics here if desired, e.g., auto-populate and process
                // }
            });

            // æ›´æ–°ä¸»ç»“æœå¤åˆ¶æŒ‰é’®çš„äº‹ä»¶ç›‘å¬å™¨
            if (copyBtn) {
                copyBtn.addEventListener('click', async () => {
                    const originalText = resultDiv?.getAttribute('data-original-text');
                    if (!originalText) return;
                    
                    const success = await copyTextToClipboard(originalText);
                    if (success) {
                        copyBtn.textContent = 'å·²å¤åˆ¶';
                        copyBtn.classList.add('copied');
                        setTimeout(() => {
                            copyBtn.textContent = 'å¤åˆ¶ç»“æœ';
                            copyBtn.classList.remove('copied');
                        }, 2000);
                    } else {
                        alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶æ–‡æœ¬');
                    }
                });
            }

            // Base64 Input Toggle & Input Handling
            if (toggleBase64 && base64Input && urlInput && toggleUrl) {
                toggleBase64.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const show = base64Input.style.display === 'none';
                    base64Input.style.display = show ? 'block' : 'none';
                    toggleBase64.textContent = show ? 'éšè—Base64è¾“å…¥' : 'Base64è¾“å…¥';
                    if (show) {
                        urlInput.style.display = 'none';
                        toggleUrl.textContent = 'URLè¾“å…¥';
                        base64Input.focus();
                        if(previewImage) previewImage.style.display = 'none'; // Hide preview when switching
                        if(resultContainer) resultContainer.classList.remove('show');
                    }
                });
                base64Input.addEventListener('click', e => e.stopPropagation());
                base64Input.addEventListener('input', (e) => processBase64Debounced(e.target.value.trim()));
            }

            // URL Input Toggle & Input Handling
            if (toggleUrl && urlInput && base64Input && toggleBase64) {
                toggleUrl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const show = urlInput.style.display === 'none';
                    urlInput.style.display = show ? 'block' : 'none';
                    toggleUrl.textContent = show ? 'éšè—URLè¾“å…¥' : 'URLè¾“å…¥';
                    if (show) {
                        base64Input.style.display = 'none';
                        toggleBase64.textContent = 'Base64è¾“å…¥';
                        urlInput.focus();
                        if(previewImage) previewImage.style.display = 'none'; // Hide preview when switching
                        if(resultContainer) resultContainer.classList.remove('show');
                    }
                });
                urlInput.addEventListener('click', e => e.stopPropagation());
                urlInput.addEventListener('input', (e) => processUrlDebounced(e.target.value.trim()));
            }

             // Advanced Mode Toggle & Prompt Saving
             if (advancedMode && promptContainer && promptInput) {
                advancedMode.addEventListener('change', () => {
                    const isChecked = advancedMode.checked;
                    promptContainer.style.display = isChecked ? 'block' : 'none'; // More direct style manipulation
                    localStorage.setItem('advancedMode', String(isChecked));
                    // Save prompt immediately when toggling advanced mode ON
                    if (isChecked) {
                         localStorage.setItem('customPrompt', promptInput.value);
                    }
                });
                // Save prompt on input change (debounced), only if advanced mode is checked
                promptInput.addEventListener('input', debounce(() => {
                    if (advancedMode.checked) {
                         localStorage.setItem('customPrompt', promptInput.value);
                    }
                }, 500));
             }

            // Image Modal Close
            if (modal) {
                modal.onclick = () => { modal.style.display = "none"; modalImg.src = ''; }; // Clear src on close
            }
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal?.style.display === 'block') {
                     modal.style.display = 'none';
                     modalImg.src = ''; // Clear src on close
                }
            });

        } // End of setupEventListeners

        // --- Load Initial Settings & Setup ---
        function loadInitialSettings() {
            // Load cookie and update token display
            const savedCookie = localStorage.getItem('imageRecognitionCookie');
            if (savedCookie && cookieInput) {
                cookieInput.value = savedCookie;
                const tokenMatch = savedCookie.match(/token=([^;]+)/);
                updateTokenDisplay(tokenMatch ? tokenMatch[1] : null);
            } else {
                 updateTokenDisplay(null); // Ensure UI reflects no token state
            }

            // Load advanced mode settings
            const savedMode = localStorage.getItem('advancedMode') === 'true';
            const savedPrompt = localStorage.getItem('customPrompt');
            if(advancedMode) advancedMode.checked = savedMode;
            if(promptContainer) promptContainer.style.display = savedMode ? 'block' : 'none';
            if(promptInput && savedPrompt) promptInput.value = savedPrompt;
            // Set default prompt if none is saved and advanced mode is off initially
             else if (promptInput && !savedPrompt && !savedMode) {
                 // Set the default prompt text here if needed
                 // promptInput.value = "Default prompt text...";
             }


            // Display initial history for the loaded token
            historyManager.displayHistory(currentToken);
        }

        // --- History Action Functions (must be global) ---
        async function copyHistoryResult(index, btn) {
            if (!currentToken) return;
            try {
                const history = historyManager.loadHistory(currentToken);
                const historyItemDiv = document.querySelector(`.history-sidebar .history-item[data-index="${index}"] .history-text`);
                const result = historyItemDiv?.getAttribute('data-original-text') || history[index]?.result;

                if (!result) throw new Error('æ— æ³•è·å–ç»“æœæ–‡æœ¬');

                const success = await copyTextToClipboard(result);
                if (success) {
                    btn.textContent = 'å·²å¤åˆ¶';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        const currentBtn = document.querySelector(`.history-sidebar .history-item[data-index="${index}"] .action-btn.copy-btn`);
                        if (currentBtn) {
                            currentBtn.textContent = 'å¤åˆ¶ç»“æœ';
                            currentBtn.classList.remove('copied');
                        }
                    }, 2000);
                } else {
                    throw new Error('å¤åˆ¶æ“ä½œå¤±è´¥');
                }
            } catch (err) {
                console.error('å¤åˆ¶å†å²è®°å½•å¤±è´¥:', err);
                alert('å¤åˆ¶å¤±è´¥: ' + (err.message || 'è¯·æ‰‹åŠ¨å¤åˆ¶æ–‡æœ¬'));
            }
        }

        function deleteHistoryItem(index) {
            if (!currentToken) return;
            const history = historyManager.loadHistory(currentToken);
            if (index < 0 || index >= history.length) return;

            if (confirm(`ç¡®å®šè¦åˆ é™¤ç¬¬ ${index + 1} æ¡å†å²è®°å½•å—ï¼Ÿ`)) {
                history.splice(index, 1);
                historyManager.saveHistory(currentToken, history);
                historyManager.displayHistory(currentToken); // Re-render
            }
        }


        // --- Run Setup on DOM Load ---
        document.addEventListener('DOMContentLoaded', () => {
            loadInitialSettings();
            setupEventListeners();
        });

    </script>
</body>
</html>